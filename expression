% E in Arithmetic Expression
% I in Identifier
% N in Number
% E ::= E + E | E - E | E * E | E / E | (E) | I | N



% I ::= x | y | z | u | v


% E ::= N
% N ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
:- use_rendering(svgtree).
% Define DCG rules for parsing expressions
number([0]) --> [0].
number([1]) --> [1].
number([2]) --> [2].
number(number(3)) --> [3].
number([4]) --> [4].
number([5]) --> [5].
number([6]) --> [6].
number([7]) --> [7].
number([8]) --> [8].
number([9]) --> [9].

variable([x]) --> [x].
variable([y]) --> [y].
variable([z]) --> [z].
variable([u]) --> [u].
variable([v]) --> [v].


% E ::= E + E  | I | N
% E :: = I + E | N + E | I | N
% Beta ::= I | N | E
% Alpha ::= + E | epsilon




expr(Num) --> number(Num).
expr(Var) --> variable(Var).
expr(plus(Var,  E)) --> variable(Var), ['+'], expr(E).
expr(plus(Num,  E)) --> number(Num), ['+'], expr(E).





% Define DCG rule for parsing expressions


% Example usage:
%  expr(Tree, [3], []).

% expr(Tree, [3, '+', 5], []).
% expr(Tree, [3, '-', 2, '+', 1], []).

% Define eval_expr predicate
eval_expr(Tree, Env, Result) :-
    eval(Tree, Env, Result).

% Define evaluation rules for different types of expressions
eval(number(N), _, N).

eval(variable(Var), Env, Value) :-
    lookup(Var, Env, Value).

% Define evaluation rules for different types of expressions
eval(number(N), _, N).

eval(variable(Var), Env, Value) :-
    lookup(Var, Env, Value).

eval(plus(Left, Right), Env, Result) :-
    eval(Left, Env, LeftResult),
    eval(Right, Env, RightResult),
    Result is LeftResult + RightResult.


% Define lookup predicate to retrieve variable value from environment
lookup(Var, [(Var, Value) | _], Value).
lookup(Var, [_ | T], Value) :-
    lookup(Var, T, Value).

